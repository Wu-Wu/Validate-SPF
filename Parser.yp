%{#
# Validate::SPF::Parser source file
#
# Author: Anton Gerasimov
#

my $input;

my %errors = (
    E_DEFAULT           => "Just error",
    E_SYNTAX            => "Syntax error near token '%s'",
    E_INVALID_VERSION   => "Invalid SPF version",
);

%}

%%

spf
    : chunks
        { $_[1] }
    ;

version
    : VERSION
        {
            $_[1] eq 'v=spf1' and
                return +{ type => 'ver', version => $_[1] };

            $_[0]->raise_error( 'E_INVALID_VERSION', $_[1] );
        }
    ;

chunks
    : chunks chunk
        { push( @{$_[1]}, $_[2] ) if defined $_[2]; $_[1] }
    | chunk
        { defined $_[1] ? [ $_[1] ] : [ ] }
    ;

chunk
    : version
    | mechanism
    ;

mechanism
    : with_ipaddress
    | with_domain_bitmask
    | with_bitmask
    | with_domain
    | bare
    ;

# all
bare
    : ALL
        { +{ type => 'mech', qualifer => '+', mechanism => $_[1] } }
    | QUALIFER ALL
        { +{ type => 'mech', qualifer => $_[1], mechanism => $_[2] } }
    ;

# ptr, exists, include, mx, a
with_domain
    : MECHANISM
        { +{ type => 'mech', qualifer => '+', mechanism => $_[1], domain => '@' } }
    | QUALIFER MECHANISM
        { +{ type => 'mech', qualifer => $_[1], mechanism => $_[2], domain => '@' } }
    | MECHANISM ':' DOMAIN
        { +{ type => 'mech', qualifer => '+', mechanism => $_[1], domain => $_[3] } }
    | QUALIFER MECHANISM ':' DOMAIN
        { +{ type => 'mech', qualifer => $_[1], mechanism => $_[2], domain => $_[4] } }
    ;

# mx, a
with_bitmask
    : MECHANISM '/' BITMASK
        { +{ type => 'mech', qualifer => '+', mechanism => $_[1], domain => '@', bitmask => $_[3] } }
    | QUALIFER MECHANISM '/' BITMASK
        { +{ type => 'mech', qualifer => $_[1], mechanism => $_[2], domain => '@', bitmask => $_[4] } }
    ;

# mx, a
with_domain_bitmask
    : MECHANISM ':' DOMAIN '/' BITMASK
        { +{ type => 'mech', qualifer => '+', mechanism => $_[1], domain => $_[3], bitmask => $_[5] } }
    | QUALIFER MECHANISM ':' DOMAIN '/' BITMASK
        { +{ type => 'mech', qualifer => $_[1], mechanism => $_[2], domain => $_[4], bitmask => $_[6] } }
    ;

# ip4, ip6
with_ipaddress
    : MECHANISM ':' IPADDRESS
        { +{ type => 'mech', qualifer => '+', mechanism => $_[1], ipaddress => $_[3] } }
    | QUALIFER MECHANISM ':' IPADDRESS
        { +{ type => 'mech', qualifer => $_[1], mechanism => $_[2], ipaddress => $_[4] } }
    | MECHANISM ':' IPADDRESS '/' BITMASK
        { +{ type => 'mech', qualifer => '+', mechanism => $_[1], network => $_[3], bitmask => $_[5] } }
    | QUALIFER MECHANISM ':' IPADDRESS '/' BITMASK
        { +{ type => 'mech', qualifer => $_[1], mechanism => $_[2], network => $_[4], bitmask => $_[6] } }
    ;

%%

sub parse {
    my ( $self, $text ) = @_;

    $input = $self->YYData->{INPUT} = $text;
    delete $self->YYData->{ERRMSG};

    return $self->YYParse( yylex => \&_lexer, yyerror => \&_error );
}

sub error {
    my ( $self ) = @_;
    return $self->YYData->{ERRMSG};
}

sub _build_error {
    my ( $self, $code, $context, @extra ) = @_;

    $code = 'E_DEFAULT'     unless exists $errors{$code};

    $self->YYData->{ERRMSG} = {
        text    => sprintf( $errors{$code} => @extra ),
        code    => $code,
        context => $context,
    };
}

sub raise_error {
    my ( $self, @params ) = @_;

    $self->_build_error( @params );
    $self->YYError;
}

sub _error {
    my ( $self ) = @_;

    unless ( exists $self->YYData->{ERRMSG} ) {
        substr( $input, index( $input, $self->YYCurval ), 0, '<*>' );

        $self->_build_error( 'E_SYNTAX', $input, $self->YYCurval );
    }

    return;
}

sub _lexer {
    my ( $parser ) = @_;

    $parser->YYData->{INPUT} =~ s/^\s*//;

    for ( $parser->YYData->{INPUT} ) {
        # printf( "[debug] %s\n", $_ );

        s/^(v\=spf\d)\b//i
            and return ( 'VERSION', $1 );

        s/^(\/)\b//i
            and return ( '/', '/' );
        s/^(\:)\b//i
            and return ( ':', ':' );
        s/^(\=)\b//i
            and return ( '=', '=' );

        # qualifers
        s/^([-~\+\?])\b//i
            and return ( 'QUALIFER', $1 );

        # mechanisms
        s/^(all|ptr|a|mx|ip4|ip6|exists|include)\b//i
            and return ( 'MECHANISM', $1 );

        s/^((\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})|(([a-f\d]{1,4}:){7,7}[a-f\d]{1,4}|([a-f\d]{1,4}:){1,7}:|([a-f\d]{1,4}:){1,6}:[a-f\d]{1,4}|([a-f\d]{1,4}:){1,5}(:[a-f\d]{1,4}){1,2}|([a-f\d]{1,4}:){1,4}(:[a-f\d]{1,4}){1,3}|([a-f\d]{1,4}:){1,3}(:[a-f\d]{1,4}){1,4}|([a-f\d]{1,4}:){1,2}(:[a-f\d]{1,4}){1,5}|[a-f\d]{1,4}:((:[a-f\d]{1,4}){1,6})|:((:[a-f\d]{1,4}){1,7}|:)|fe80:(:[a-f\d]{0,4}){0,4}%[a-z\d]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[\d]){0,1}[\d])|([a-f\d]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[\d]){0,1}[\d]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[\d]){0,1}[\d])))\b//i
            and return ( 'IPADDRESS', $1 );

        s/^([_\.a-z\d][\-a-z\d]*\.[\.\-a-z\d]*[a-z\d]?)\b//i
            and return ( 'DOMAIN', $1 );

        s/^(\d{1,3})\b//i
            and return ( 'BITMASK', $1 );

        # garbage
        s/^(.+)\b//i
            and return ( 'UNKNOWN', $1 );
    }

    # EOF
    return ( '', undef );
}
