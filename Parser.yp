%{#
# Validate::SPF::Parser source file
#
# Author: Anton Gerasimov
#

use Regexp::Common qw( net );

my $input;

my %errors = (
    E_DEFAULT               => "Just error",
    E_SYNTAX                => "Syntax error near token '%s'",
    E_INVALID_VERSION       => "Invalid SPF version",
    E_IPADDR_EXPECTED       => "Expected ip or network address",
    E_DOMAIN_EXPECTED       => "Expected domain name"
);

%}

%%

spf
    : chunks
        { $_[1] }
    ;

version
    : VERSION
        {
            $_[1] eq 'v=spf1' and
                return +{ type => 'ver', version => $_[1] };

            $_[0]->raise_error( 'E_INVALID_VERSION', $_[1] );
        }
    ;

chunks
    : chunks chunk
        { push( @{$_[1]}, $_[2] ) if defined $_[2]; $_[1] }
    | chunk
        { defined $_[1] ? [ $_[1] ] : [ ] }
    ;

chunk
    : version
    | mechanism
    | modifier
    ;

mechanism
    : with_ipaddress
    | with_domain_bitmask
    | with_bitmask
    | with_domain
    ;

modifier
    : MODIFIER '=' DOMAIN
        { +{ type => 'mod', modifier => lc $_[1], domain => $_[3] } }
    ;

# ptr, exists, include, mx, a, all
with_domain
    : MECHANISM
        {
            $_[0]->raise_error( 'E_IPADDR_EXPECTED', $_[1] )    if $_[1] =~ /ip[46]/i;
            $_[0]->raise_error( 'E_DOMAIN_EXPECTED', $_[1] )    if $_[1] =~ /exists|include/i;

            +{
                type => 'mech',
                qualifer => '+',
                mechanism => lc $_[1],
                ( $_[1] =~ /all/i ? () : ( domain => '@' ) )
            };
        }
    | QUALIFER MECHANISM
        {
            $_[0]->raise_error( 'E_IPADDR_EXPECTED', $_[2] )    if $_[2] =~ /ip[46]/i;
            $_[0]->raise_error( 'E_DOMAIN_EXPECTED', $_[2] )    if $_[2] =~ /exists|include/i;

            +{
                type => 'mech',
                qualifer => $_[1],
                mechanism => lc $_[2],
                ( $_[2] =~ /all/i ? () : ( domain => '@' ) )
            };
        }
    | MECHANISM ':' DOMAIN
        { +{ type => 'mech', qualifer => '+', mechanism => lc $_[1], domain => $_[3] } }
    | QUALIFER MECHANISM ':' DOMAIN
        { +{ type => 'mech', qualifer => $_[1], mechanism => lc $_[2], domain => $_[4] } }
    ;

# mx, a
with_bitmask
    : MECHANISM '/' BITMASK
        { +{ type => 'mech', qualifer => '+', mechanism => lc $_[1], domain => '@', bitmask => $_[3] } }
    | QUALIFER MECHANISM '/' BITMASK
        { +{ type => 'mech', qualifer => $_[1], mechanism => lc $_[2], domain => '@', bitmask => $_[4] } }
    ;

# mx, a
with_domain_bitmask
    : MECHANISM ':' DOMAIN '/' BITMASK
        { +{ type => 'mech', qualifer => '+', mechanism => lc $_[1], domain => $_[3], bitmask => $_[5] } }
    | QUALIFER MECHANISM ':' DOMAIN '/' BITMASK
        { +{ type => 'mech', qualifer => $_[1], mechanism => lc $_[2], domain => $_[4], bitmask => $_[6] } }
    ;

# ip4, ip6
with_ipaddress
    : MECHANISM ':' IPADDRESS
        { +{ type => 'mech', qualifer => '+', mechanism => lc $_[1], ipaddress => $_[3] } }
    | QUALIFER MECHANISM ':' IPADDRESS
        { +{ type => 'mech', qualifer => $_[1], mechanism => lc $_[2], ipaddress => $_[4] } }
    | MECHANISM ':' IPADDRESS '/' BITMASK
        { +{ type => 'mech', qualifer => '+', mechanism => lc $_[1], network => $_[3], bitmask => $_[5] } }
    | QUALIFER MECHANISM ':' IPADDRESS '/' BITMASK
        { +{ type => 'mech', qualifer => $_[1], mechanism => lc $_[2], network => $_[4], bitmask => $_[6] } }
    ;

%%

sub parse {
    my ( $self, $text ) = @_;

    $input = $self->YYData->{INPUT} = $text;
    delete $self->YYData->{ERRMSG};

    return $self->YYParse( yylex => \&_lexer, yyerror => \&_error );
}

sub error {
    my ( $self ) = @_;
    return $self->YYData->{ERRMSG};
}

sub _build_error {
    my ( $self, $code, $context, @extra ) = @_;

    $code = 'E_DEFAULT'     unless exists $errors{$code};

    $self->YYData->{ERRMSG} = {
        text    => sprintf( $errors{$code} => @extra ),
        code    => $code,
        context => $context,
    };
}

sub raise_error {
    my ( $self, @params ) = @_;

    $self->_build_error( @params );
    $self->YYError;
}

sub _error {
    my ( $self ) = @_;

    unless ( exists $self->YYData->{ERRMSG} ) {
        substr( $input, index( $input, $self->YYCurval ), 0, '<*>' );

        $self->_build_error( 'E_SYNTAX', $input, $self->YYCurval );
    }

    return;
}

sub _lexer {
    my ( $parser ) = @_;

    $parser->YYData->{INPUT} =~ s/^\s*//;

    for ( $parser->YYData->{INPUT} ) {
        # printf( "[debug] %s\n", $_ );

        s/^(v\=spf\d)\b//i
            and return ( 'VERSION', $1 );

        s/^(\/)\b//i
            and return ( '/', '/' );
        s/^(\:)\b//i
            and return ( ':', ':' );
        s/^(\=)\b//i
            and return ( '=', '=' );

        # qualifers
        s/^([-~\+\?])\b//i
            and return ( 'QUALIFER', $1 );

        # mechanisms
        s/^(all|ptr|a|mx|ip4|ip6|exists|include)\b//i
            and return ( 'MECHANISM', $1 );

        # modifiers
        s/^(redirect|exp)\b//i
            and return ( 'MODIFIER', $1 );

        s/^($RE{net}{IPv4}{dec}|$RE{net}{IPv6}{-sep=>':'})\b//i
            and return ( 'IPADDRESS', $1 );

        s/^([_\.a-z\d][\-a-z\d]*\.[\.\-a-z\d]*[a-z\d]?)\b//i
            and return ( 'DOMAIN', $1 );

        s/^(\d{1,3})\b//i
            and return ( 'BITMASK', $1 );

        # garbage
        s/^(.+)\b//i
            and return ( 'UNKNOWN', $1 );
    }

    # EOF
    return ( '', undef );
}
