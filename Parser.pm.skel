package <<$package>>;

# ABSTRACT: SPF v1 parser implementation

####################################################################
#
#    This file was generated using Parse::Yapp version <<$version>>.
#
#        Don't edit this file, use source file instead.
#
#             ANY CHANGE MADE HERE WILL BE LOST !
#
####################################################################

use strict;
use warnings;

# VERSION
# AUTHORITY

use vars qw ( @ISA );

@ISA = qw( Parse::Yapp::Driver );

<<$driver>>

<<$head>>

=head1 SYNOPSIS

    use <<$package>>;

    $parser = <<$package>>->new;
    $ast = $parser->parse( 'v=spf1 a include:_spf.example.com ~all' );

    unless ( $ast ) {
        # fail
        print "Error: " . $parser->error->{code} . ": " . $parser->error->{text} . "\n";
    }
    else {
        # ok
        ...
    }

=method new

Creates an instance of SPF parser.

    my $parser = <<$package>>->new;

=cut

sub new {
    my( $class ) = shift;

    ref( $class ) and $class = ref( $class );

    my $self =
        $class->SUPER::new(
            yyversion   => '<<$version>>',
            yystates    => <<$states>>,
            yyrules     => <<$rules>>,
            @_
        );

    bless $self, $class;
}

=method parse

Builds an abstract syntax tree (AST) for given text representation of SPF.

    my $ast = $parser->parse( 'v=spf1 ~all' );

Returns an C<undef> if error occured. See L</error> for details.

=method error

Returns last error occured as HashRef.

    $parser->error;

Here is an example

    {
       code    => 'E_SYNTAX',
       text    => 'Syntax error',
       context => 'v=spf1 <*>exclude:foo.example.com  mx ~all',
    }

=for Pod::Coverage _error _lexer

=head1 BUILD PARSER

In cases of C<Parser.yp> was modified you should re-build this module. Ensure you have L<Parse::Yapp>
distribution installed.

In root directory:

    $ yapp -s -m Validate::SPF::Parser -o lib/Validate/SPF/Parser.pm -t Parser.pm.skel Parser.yp

Ensure the C<lib/Validate/SPF/Parser.pm> saved without tab symbols and has unix line endings.

=head1 SEE ALSO

L<Parse::Yapp>

=cut

<<$tail>>
1;
